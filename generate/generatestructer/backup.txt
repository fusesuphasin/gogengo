package generatestructer

import (
	"fmt"
	"gogenerate/createstructer/gotemplate"
	"log"
	"os"
	"strings"
	"time"
)

type TemplateValue struct {
	NewmethodURL   string
	CURL           string
	NewMethod      string
	ControllerName string
	CtlMethod      string
}

func Createroute(url *map[string][]string, keys *[]string) {
	f, err := os.Create("logismate/route/route.go")
	die(err)
	defer f.Close()

	copyURL := *url

	urlKeys := make([]string, 0, len(*url))

	gotemplate.PackageTemplate.Execute(f, struct {
		Timestamp time.Time
		URL       map[string][]string
		URLKeys   []string
	}{
		Timestamp: time.Now(),
		URL:       *url,
		URLKeys:   urlKeys,
	})

	for k := range *url {
		urlKeys = append(urlKeys, k)
	}

	//write controller template
	for i := 0; i < 2; i++ {
		checkDupicate := make(map[string]int)
		for j, _ := range *url {

			url := strings.Split(j, "/")
			ctl := url[1]
			ControllerName := strings.Title(ctl)
			newCTLName := ""
			for _, v := range  ControllerName {
				v := string(v)
				if(v==":"||v=="?"||v=="="||v=="&"){
					break
				}
				newCTLName += v
			}
			checkDupicate[newCTLName]++
			ControllerName = newCTLName
			switch i {
			case 0:
				{
					if checkDupicate[newCTLName] == 1 {
						controllerName := fmt.Sprintf("logismate/controller/%vcontroller.go", strings.ToLower(ControllerName))
						ctl, err := os.Create(controllerName)
						die(err)
						defer f.Close()
						gotemplate.CtlpackageTemplate.Execute(ctl, struct {
							Timestamp      time.Time
							ControllerName string
						}{
							Timestamp:      time.Now(),
							ControllerName: ControllerName,
						})

						gotemplate.ControllerTemplate.Execute(f, struct {
							Timestamp      time.Time
							ControllerName string
						}{
							Timestamp:      time.Now(),
							ControllerName: ControllerName,
						})

						checkDupicateURL := make(map[string]int)
						checkDupicateURL2 := make(map[string]int)
						for cURL, cValue := range copyURL {
							log.Println(cURL)
							checkURLprev := strings.Split(j, "/")
							checkURLcurr := strings.Split(cURL, "/")

							newCurrentURL := ""
							for _, v := range checkURLcurr {
								for _, v1 := range v {
									v2 := string(v1)
									if(v2=="?"||v2=="="||v2=="&"){
										break
									}
									newCurrentURL+=v2
								}
								if(v!=checkURLcurr[len(checkURLcurr)-1]){
									newCurrentURL+="/"
								}
							}
							cURL = newCurrentURL
							if checkURLprev[1] == checkURLcurr[1] {
								newcURL := strings.Split(cURL, "/")
								var NewmethodURL string
								countUncharactor := 0
								for i := 1; i < len(newcURL); i++ {
									countUncharactor = 0
									for _, v := range  newcURL[i] {
										v := string(v)
										if(v==":"||v=="?"||v=="="||v=="&"){
											countUncharactor++
										}
									}
									if countUncharactor == 0 {
										NewmethodURL += strings.Title(newcURL[i])
									}
								}
								NewmethodURL = strings.Title(NewmethodURL)

								for _, method := range cValue {

									Method := strings.ToLower(method)
									newMethod := strings.Title(Method)
									
									var ctlMethod string
									switch newMethod {
									case "Get":
										{
											if sprit:=string(checkURLcurr[len(checkURLcurr)-1]); string(sprit[0]) == ":" {
												ctlMethod = "getBy" + strings.Title(sprit[1:len(sprit)])
											} else {
												ctlMethod = "getAll"
											}
										}
									case "Post":
										{
											ctlMethod = "create"
										}
									case "Delete":
										{
											ctlMethod = "delete"
										}
									case "Put":
										{
											ctlMethod = "updateAll"
										}
									case "Patch":
										{
											ctlMethod = "update"
										}
									}
									createNewDupicate := newMethod + cURL
									checkDupicateURL[createNewDupicate]++
									if(checkDupicateURL[createNewDupicate]==1){
										//log.Println(cURL, NewmethodURL)
										gotemplate.BodyTemplate.Execute(ctl, struct {
											Timestamp      time.Time
											URL            string
											Method         string
											ControllerName string
											CtlMethod      string
											NewmethodURL   string
										}{
											Timestamp:      time.Now(),
											URL:            cURL,
											Method:         newMethod,
											ControllerName: ControllerName,
											CtlMethod:      ctlMethod,
											NewmethodURL:   NewmethodURL,
										})
									}
								}
							}
						}
						gotemplate.EndTemplate.Execute(ctl, struct {
							Timestamp time.Time
						}{
							Timestamp: time.Now(),
						})

						//write method for route

						for cURL, cValue := range copyURL {
							checkURLprev := strings.Split(j, "/")
							checkURLcurr := strings.Split(cURL, "/")
							

							newCurrentURL := ""
							for _, v := range checkURLcurr {
								for _, v1 := range v {
									v2 := string(v1)
									if(v2=="?"||v2=="="||v2=="&"){
										break
									}
									newCurrentURL+=v2
								}
								if(v!=checkURLcurr[len(checkURLcurr)-1]){
									newCurrentURL+="/"
								}
							}
							cURL = newCurrentURL
							if checkURLprev[1] == checkURLcurr[1] {
								for _, method := range cValue {

									Method := strings.ToLower(method)
									newMethod := strings.Title(Method)
									var ctlMethod string
									switch newMethod {
									case "Get":
										{
											if sprit:=string(checkURLcurr[len(checkURLcurr)-1]); string(sprit[0]) == ":" {
												ctlMethod = "getBy" + strings.Title(sprit[1:len(sprit)])
											} else {
												ctlMethod = "getAll"
											}
										}
									case "Post":
										{
											ctlMethod = "create"
										}
									case "Delete":
										{
											ctlMethod = "delete"
										}
									case "Put":
										{
											ctlMethod = "updateAll"
										}
									case "Patch":
										{
											ctlMethod = "update"
										}
									}

									newcURL := strings.Split(cURL, "/")
									var NewmethodURL string
									countUncharactor := 0
									for i := 1; i < len(newcURL); i++ {
										countUncharactor = 0
										for _, v := range  newcURL[i] {
											v := string(v)
											if(v==":"||v=="?"||v=="="||v=="&"){
												countUncharactor++
											}
										}
										if countUncharactor == 0 {
											NewmethodURL += strings.Title(newcURL[i])
										}
									}
									NewmethodURL = strings.Title(NewmethodURL)

									createNewDupicate2 := newMethod + cURL
									checkDupicateURL2[createNewDupicate2]++
									if(checkDupicateURL2[createNewDupicate2]==1){
										//log.Println(newMethod, cURL, ctlMethod, NewmethodURL)
										gotemplate.MethodctlTemplate.Execute(ctl, struct {
											Timestamp      time.Time
											URL            string
											Method         string
											ControllerName string
											CtlMethod      string
											NewmethodURL   string
											}{
											Timestamp:      time.Now(),
											URL:            cURL,
											Method:         newMethod,
											ControllerName: ControllerName,
											CtlMethod:      ctlMethod,
											NewmethodURL:   NewmethodURL,
										})
									}
									
								}
							}
						}
					}
				}

			//router
			case 1:
				{
					if checkDupicate[newCTLName] == 1 {
						gotemplate.CallControllerTemplate.Execute(f, struct {
							Timestamp      time.Time
							ControllerName string
						}{
							Timestamp:      time.Now(),
							ControllerName: ControllerName,
						})
					}
				}
			}

		}
		gotemplate.NewLineTemplate.Execute(f, struct {
		}{})
	}

	gotemplate.EndTemplate.Execute(f, struct {
		Timestamp time.Time
	}{
		Timestamp: time.Now(),
	})

	//write respone struct file
	controllerFileName := fmt.Sprintf("logismate/utils/response/response.go")
	res, _ := os.Create(controllerFileName)

	gotemplate.RespackageTemplate.Execute(res, struct {
		Timestamp time.Time
	}{
		Timestamp: time.Now(),
	})
}

func die(err error) {
	if err != nil {
		log.Fatal(err)
	}
}
